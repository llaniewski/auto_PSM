<?R 
	source("conf.R") 
	c_header();
	source("lib/feq.R")
	source("lib/boundary.R")
?>

/*
09.04.19 - d3q27 model for particle coupling.
	     
	Consolidated isothermal portion of J. McCullough's thermal LBM-DEM model with D. Wang's TRT collision operator and modified weighting function for the PSM (based on LBM-DEM coupling of Noble & Torczynski, 1998).

	Compile options include:
		- BGK or TRT collision (BGK is default, for TRT compile with _TRT)
		- non-equilibirium-bounce-back (_NEBB) or superposition (_SUP) solid collision operators

	Maintainers: Nathan Di Vaira di_vaira@hotmail.com / Lukasz Laniewski-Wollk l.laniewskiwollk@uq.edu.au
		
Code updates:
	06.11.19 - Moving walls added
	11.12.19 - PSM coverage and modified weighting functions corrected, now correct 2nd order convergence & improved viscosity dependence
	10.01.20 - TotalFluidVelocity globals added
	25.02.20 - Manual periodicity and FullParticleIterator removed to align with TCLB particle update
    20.05.20 - LLW: Modified to moment-based implementation; consolidated to single collision function with TRT option; corrected CalcF
    14.03.22 - omegaP removed as setting, replaced with Lambda (TRT magic parameter)
    28.11.22 - Kuang-Luo rheology added as a compile option
	
*/

#define PI 3.141592653589793

<?R
	f = PV(DensityAll$name[DensityAll$group=="f"])

	u = PV("u",xyz)
	d = PV("d")

	rho = PV("rho")
	J = PV("J",xyz)

?>

CudaDeviceFunction real_t getP(){
    RunBoundaries();
	real_t rho = <?R C(sum(f)) ?>;
    return (rho-1.0)/3.0;
}

CudaDeviceFunction vector_t getU(){
    RunBoundaries();
	real_t d = <?R C(sum(f)) ?>;
	vector_t u;
<?R C(PV("u.",xyz), f %*% U) ?>
    RunCollision();
<?R C(PV("u.",xyz), PV("u.",xyz) + f %*% U) ?>
	u.x = u.x/(2*d);
	u.y = u.y/(2*d);
	u.z = u.z/(2*d);
	return u;
}

CudaDeviceFunction vector_t getUP() {
    vector_t u;
    u.x = uPx; u.y = uPy; u.z = uPz;
    return u;
}

CudaDeviceFunction real_t getSolid() { return sol; }
CudaDeviceFunction real_t getB() { return solB; }


CudaDeviceFunction void Run() {
    RunBoundaries();
    RunParticles();
    RunCollision();
}

CudaDeviceFunction void RunParticles() {
    <?R if (Options$singlekernel) { ?>
    CalcF();
    <?R } ?>
}

CudaDeviceFunction void RunBoundaries() {
    switch (NodeType & NODE_BOUNDARY) {
    <?R for (bc in rows(BC)) { ?>
        case NODE_<?%s bc$name ?>:
        <?%s bc$name ?>();
	    break;
    <?R } ?>
    }
}

CudaDeviceFunction void RunCollision() {
    if ((NodeType & NODE_COLLISION) == NODE_Wall) {
        BounceBack();
    } else if ((NodeType & NODE_COLLISION) != 0) {
        Collision();
    }
}

CudaDeviceFunction void BounceBack() {
<?R FullBounceBack() ?>
}

<?R
	EQ = MRT_eq(U, rho, J, ortogonal=FALSE);
    for (bc in rows(BC)) { ?>
CudaDeviceFunction void <?%s bc$name ?>() {
    <?R ZouHe(EQ, bc$direction, bc$sign, bc$type, group=f, P=PV("Pressure"), V=PV("Velocity",XYZ)[bc$direction]) ?>
}
<?R 
    }
?>


<?R
	d = PV("d")
	u = PV("u",xyz)
	uP = PV("uP",xyz)
	a = PV("Accel", XYZ)
	sol = PV("sol")
    solB = PV("solB")
    localCoverage = PV("localCoverage")
    sol_factor = PV("sol_factor")
    uparticle = PV("p.cvel.",xyz)
    force = PV("force.",xyz)
	R = PV("R[",seq_len(nrow(U))-1,"]")
	M = MRT_polyMatrix(U)$mat

    uh = u + a*0.5

	RL = R
	R[1] = d
	R[2:4] = u*d
	EQ   = MRT_eq(U, d, u*d, ortogonal=FALSE, mat=M);
	EQ_H   = MRT_eq(U, d, uh*d, ortogonal=FALSE, mat=M);
	EQ_P = MRT_eq(U, d, uP*d, ortogonal=FALSE, mat=M)
    # (u_post+u)/2 = solB*uP + (1-solB)*(u+a/2)
    u_post = solB*(2*uP-u) + (1-solB)*(u+a)
	EQ_post = MRT_eq(U, d, u_post*d, ortogonal=FALSE, mat=M)

    der.gvector = function(obj_) gapply(obj_, der)
    F = subst(
        der(EQ$feq),
        d_d=0,
        ux_d=a[1],uy_d=a[2],uz_d=a[3],
        ux=uh[1],uy=uh[2],uz=uh[3]
    )

    bounce = Bounce(U)
	B = solve(M, M[bounce,]) # Bounce-back matrix

	omegaF1 = PV(c("omegaF1"))
	omegaP1 = PV(c("omegaP1"))
    omega = V(1.0 - omegaF1,1.0 - omegaP1)[EQ$order %% 2 + 1]

    collisions = list()
    RomegaS =  R %*% B - R + EQ_P$Req - EQ_H$Req %*% B #Non-eq bounceback operator
    collisions[["NEBB"]] = R + (1.0-solB)*(omega*(EQ_H$Req - R) + (1.0 - omega*0.5)*(F %*% M)) + solB*RomegaS
    RomegaS =  EQ_P$Req - R + (1.0 - omega)*(R - EQ_H$Req) #Superposition operator
    collisions[["SUP"]] = R + (1.0-solB)*(omega*(EQ_H$Req - R) + (1.0 - omega*0.5)*(F %*% M)) + solB*RomegaS
    collisions[["EDM"]] = (1-omega)*(R - EQ$Req) + EQ_post$Req
    RomegaS =  R %*% B - R + EQ_P$Req - EQ_P$Req %*% B #Moving wall bounceback operator
    collisions[["MWBB"]] = R + (1.0-solB)*(omega*(EQ_H$Req - R) + (1.0 - omega*0.5)*(F %*% M)) + solB*RomegaS
?>

CudaDeviceFunction void CalcF() {
    real_t ux, uy, uz, d;
<?R
	C( d, sum(f) )
	C( u, f %*% U * d^{-1} )
	C( uP, 0)
	C( sol, 0)
?>
	for (auto p : ParticleIterator(X,Y,Z)) {
        real_t dist = sqrt(p.diff.x*p.diff.x + p.diff.y*p.diff.y + p.diff.z*p.diff.z);
        if ((dist - p.rad) < 0.5) {
            real_t localCoverage = 0.0;
            if ((dist - p.rad) < -1.0){
                localCoverage = 1.0;
            } else{
                localCoverage = (p.rad -  0.084/p.rad + 0.5 - dist);
            }
            if (localCoverage > 1.0){ localCoverage =  1.0;}
            if (localCoverage < 0.0){ localCoverage =  0.0;}
            sol = sol + localCoverage;
            <?R C(uP, uP + uparticle*localCoverage) ?>
        }
    }

	real_t sol_factor = 1.0;
    if (sol > 1.0e-8) sol_factor = 1.0/sol;
    <?R C(uP, uP * sol_factor) ?>
    
    if (sol > 1.0) sol = 1.0;

    switch (NodeType & NODE_TRANSFER) {
    case NODE_None:
        solB = sol;
        break;
    case NODE_TN:
        solB = sol*3*nu / (1 - sol + 3*nu);
        break;
    case NODE_LLW:
   		real_t vf = sol;
		real_t khat = nu*vf*(3-2*vf)/(2.0*(1-vf)*(1-vf) + nu*vf*(3-2*vf));
		solB = khat;
        break;
    }
    
    vector_t force;

    real_t omegaF = 1.0/(3.0*nu+0.5);
    real_t omegaF1 = 1.0 - omegaF;
    real_t omegaP1 = omegaF1;

    switch (NodeType & NODE_COLLISION) {
    case NODE_TRT:
        real_t omegaP = 1.0/(Lambda/(1.0/omegaF1-0.5)+0.5);
        omegaP1 = 1.0 - omegaP;
        break;
    }

    switch (NodeType & NODE_FORCING) {
    <?R for (n in names(collisions)) { ?>
    case NODE_<?%s n ?>: { <?R
        mom1 = collisions[[n]][2:4]
        mom1 = subst(mom1, solB=0) - mom1
        mom1 = mom1 * d^{-1}
        C(force, mom1); ?> } break;
    <?R } ?>
    }
    
	for (auto p : SyncParticleIterator(X,Y,Z)) {

        real_t dist = sqrt(p.diff.x*p.diff.x + p.diff.y*p.diff.y + p.diff.z*p.diff.z);
                    
        if ((dist - p.rad) < 0.5) {
            real_t localCoverage = 0.0;
            if ((dist - p.rad) < -1.0){
                localCoverage = 1.0;
            } else{
                localCoverage = (p.rad -  0.084/p.rad + 0.5 - dist);
            }
            if (localCoverage > 1.0){ localCoverage =  1.0;}
            if (localCoverage < 0.0){ localCoverage =  0.0;}
            vector_t fparticle;
<?R
            fparticle = PV("fparticle.",xyz)
            C(fparticle, force * localCoverage * sol_factor)
?>
            p.applyForce(fparticle);
        }
    }
}

CudaDeviceFunction void Collision() {
	real_t ux, uy, uz, d, R[27];
<?R
    C( RL, f %*% M)
	C( d, RL[1])
	C( u, RL[2:4]*d^{-1})
?>
    AddToTotalFluidMomentumX(d*ux);
    AddToTotalFluidMomentumY(d*uy);
    AddToTotalFluidMomentumZ(d*uz);
    AddToTotalFluidMass(d);
    AddToTotalFluidVolume(1);

    real_t omegaF = 1.0/(3.0*nu+0.5);
    real_t omegaF1 = 1.0 - omegaF;
    real_t omegaP1 = omegaF1;

    switch (NodeType & NODE_COLLISION) {
    case NODE_TRT:
        real_t omegaP = 1.0/(Lambda/(1.0/omegaF1-0.5)+0.5);
        omegaP1 = 1.0 - omegaP;
        break;
    }

    switch (NodeType & NODE_FORCING) {
    <?R for (n in names(collisions)) { ?>
    case NODE_<?%s n ?>: { <?R C(RL, collisions[[n]]); ?> } break;
    <?R } ?>
    }
<?R
	C( f, RL %*% solve(M))
?>
}

CudaDeviceFunction void Init() {
	real_t d,uhatx,uhaty,uhatz;
    d = 1.0 + 3.0*Pressure;
	uhatx = VelocityX;
    uhaty = VelocityY;
    uhatz = VelocityZ;
<?R
    uhat = PV("uhat",xyz)
	C( uP, 0)
	C( sol, 0)
?>
	for (auto p : ParticleIterator(X,Y,Z)) {
        real_t dist = sqrt(p.diff.x*p.diff.x + p.diff.y*p.diff.y + p.diff.z*p.diff.z);
        if ((dist - p.rad) < 0.5) {
            real_t localCoverage = 0.0;
            if ((dist - p.rad) < -1.0){
                localCoverage = 1.0;
            } else{
                localCoverage = (p.rad -  0.084/p.rad + 0.5 - dist);
            }
            if (localCoverage > 1.0){ localCoverage =  1.0;}
            if (localCoverage < 0.0){ localCoverage =  0.0;}
            sol = sol + localCoverage;
            <?R C(uP, uP + uparticle*localCoverage) ?>
        }
    }

	real_t sol_factor = 1.0;
    if (sol > 1.0e-8) sol_factor = 1.0/sol;
    <?R C(uP, uP * sol_factor) ?>
    
    if (sol > 1.0) sol = 1.0;

    switch (NodeType & NODE_TRANSFER) {
    case NODE_None:
        solB = sol;
        break;
    case NODE_TN:
        solB = sol*3*nu / (1 - sol + 3*nu);
        break;
    case NODE_LLW:
   		real_t vf = sol;
		real_t khat = nu*vf*(3-2*vf)/(2.0*(1-vf)*(1-vf) + nu*vf*(3-2*vf));
		solB = khat;
        break;
    }

    real_t omegaF = 1.0/(3.0*nu+0.5);
    real_t omegaF1 = 1.0 - omegaF;
    real_t omegaP1 = omegaF1;

    switch (NodeType & NODE_COLLISION) {
    case NODE_TRT:
        real_t omegaP = 1.0/(Lambda/(1.0/omegaF1-0.5)+0.5);
        omegaP1 = 1.0 - omegaP;
        break;
    }

    switch (NodeType & NODE_FORCING) {
    <?R for (n in names(collisions)) { ?>
    case NODE_<?%s n ?>: { <?R
    # u = uhat - F(uhat)/2
    # u* = u + F(uhat)
    # F(uhat) = u* - u
    # uhat = u + F(uhat)/2
    # uhat = u + (u* - u)/2 = (u* + u)/2
        mom1 = collisions[[n]][2:4]
        mom1 = (subst(mom1, solB=0) + mom1)*0.5
        mom1 = mom1 * d^{-1}
        for (i in 1:3) C_pull((mom1 - uhat)[i], ToC(u)[i])
    ?> } break;
    <?R } ?>
    }
    <?R
        EQ = MRT_eq(U, d, d*u, ortogonal=FALSE);
        C(f, EQ$feq)
    ?>
    CalcF();
    RunCollision();
}


CudaDeviceFunction float2 Color() {
    float2 ret;
    vector_t u = getU();
    ret.x = sqrt(u.x*u.x + u.y*u.y + u.z*u.z);
    ret.y = 1.0 - sol;
    return ret;
}
